#!/bin/bash
while true
do

##############################################################################################################

# Banner

f_banner(){
echo
echo "
 ____ _ ___    ____ _  _ ___ ____   ____ ____ ___ _  _ ___ 
 ==== | |==]   |--| |__|  |  [__]   ==== |===  |  |__| |--'
|     .-.
|    /   \         .-.
|   /     \       /   \       .-.     .-.     _   _
+--/-------\-----/-----\-----/---\---/---\---/-\-/-\/\/---
| /         \   /       \   /     '-'     '-'
|/           '-'         '-'

For ubuntu 18.04"
echo
echo

}

##############################################################################################################

# Setup email if need, but needed 

inbox=admin@localhost

##############################################################################################################

# Installing Dependencies
# Needed Prerequesites will be set up here

install_dep(){
   spinner
   pkgs_list='sshpass scp'
   for pkgs in $pkgs_list ;do
   if ! dpkg -s ${pkgs} >/dev/null 2>&1; then
   apt-get -y install ${pkgs}
   else
   echo -e "${pkgs} is installed - ${RED}OK${NC} "
   fi
   done
   say_done
}

##############################################################################################################

# Spinner

spinner ()
{
    bar=" ++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    barlength=${#bar}
    i=0
    while ((i < 100)); do
        n=$((i*barlength / 100))
        printf "\e[00;34m\r[%-${barlength}s]\e[00m" "${bar:0:n}"
        ((i += RANDOM%5+2))
        sleep 0.02
    done
}

##############################################################################################################

# Show "Done."

function say_done() {
    echo " "
    echo -e "Done."
    yes "" | say_continue
}

##############################################################################################################

# Ask to Continue

function say_continue() {
    echo -n " To EXIT Press x Key, Press ENTER to Continue"
    read acc
    if [ "$acc" == "x" ]; then
        exit
    fi
    echo " "
}
##############################################################################################################

# Show "Done."

function say_done_2() {
    echo " "
    echo -e "Done."
    say_continue_2
}
##############################################################################################################

# Ask to Continue

function say_continue_2() {
    echo -n " To EXIT Press x Key, Press ENTER to Continue"
    read acc
    if [ "$acc" == "x" ]; then
        exit
    fi
    echo " "
}
##############################################################################################################

# Autodetect IP address and pre-fill for the user

IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)

##############################################################################################################

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
export DISPLAY=:0.0

################################################

GREEN='\033[0;32m'      # ${GREEN}
RED='\033[0;31m'
NC='\033[0m' # No Color

################################################

date=$(date +%F_%H-%M)
time=$"`date "+%H:%M:%S"`";

################################################

update_system(){
#dpkg --status libdb-dev | grep -q not-installed
#if [ $? -eq 0 ]; then
#    apt-get install libdb-dev
#fi
# update and upgrade
 apt-get -y update
}

#######################################################################

check_main_servers_list(){

if [ -f /root/main_servers_list ] ; then
echo "Файл '/root/main_servers_list существует - ok!"
else
echo "Файл '/root/main_servers_list не существует"
echo "### Вставьте строки с серверами и нажмите 'Ctrl + O' потом 'Enter' и 'Ctrl + X'###" > /root/main_servers_list
nano /root/main_servers_list
sed -i -e "1d" /root/main_servers_list
fi


}
#######################################################################
generate_and_copy_ssh_key(){

while IFS=":" read server port passwordserver server_id; do

echo "Generating key for mainserver"
echo "================================="
sleep 1
if [ ! -f /root/.ssh/id_rsa ]; then
echo "Локальный ключ не существует. Генерируем новый."
ssh-keygen -t rsa -N "" -f /root/.ssh/id_rsa
chmod 0400 /root/.ssh/id_rsa
else
echo "Локальный ключ существует"
fi

if ssh -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server}; then
echo "Ключ уже был загружен ранее на ${server} "
continue;
else 

echo ""
echo "Копируем ключ на ${server}"
echo "================================="

echo -e " ${GREEN}Now we connect to new $server! ${NC}"

sshpass -p ${passwordserver} ssh-copy-id -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa.pub -p $port root@${server}

sleep 1

fi

done < /root/main_servers_list
}
#######################################################################
remote_sib_copy_shells(){

#IFS=":" read -p "введите данные в формате 'ip:пароль:id'  - " server passwordserver server_id

while IFS=":" read server port passwordserver server_id; do

echo -e " ${GREEN}Now we connect to $server !${NC}"

#sshpass -p ${passwordserver} ssh-copy-id -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa.pub -p $port root@${server}
#sleep 1

if [[ "$port" = "50099" ]] ; then

 if [ -s /root/shells/${server_id}.txt ]; then

  if scp -i /root/.ssh/id_rsa -P $port /root/shells/${server_id}.txt root@${server}:~/newshells.txt; then
  echo "Шеллы успешно загружены на ${server}"
  else
  echo "Ошибка загрузки шеллов на ${server}"
  fi

#sshpass -p ${passwordserver} scp -P $port /root/shells/${server_id}.txt root@176.10.118.210:newshells.txt


  if ssh -n -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server} 'bash ~/shells_updater.sh'; then

  echo "Шеллы успешно обновлены на ${server}"
  else
  echo "Ошибка обновления шеллов на ${server}"
  fi
 else
  echo "Файл ${server_id}.txt пустой"
  continue;
 fi



elif [[ "$port" = "22" ]] ; then

 if [ -s /root/shells/${server_id}.txt ]; then

  if scp -i /root/.ssh/id_rsa -P $port /root/shells/${server_id}.txt root@${server}:~/newshells.txt; then
  echo "Шеллы успешно загружены на ${server}"
  else
  echo "Ошибка загрузки шеллов на ${server}"
  fi

 else
  echo "Файл ${server_id}.txt пустой"
  continue;
 fi

cat > ~/shells_updater_new.sh << ELF
#!/bin/bash

#chattr -i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/shelllist.txt
#chattr -i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/goodshelllist.txt
#chattr -i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/blackshell.txt

cat /root/newshells.txt >> /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/shelllist.txt
#cat /root/newshells.txt >> /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/goodshelllist.txt

#chattr +i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/shelllist.txt
#chattr +i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/goodshelllist.txt
#chattr +i /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/blackshell.txt
ELF

sed -i "s#\<IP_TO_REPLACE\>#$server#g" /root/shells_updater_new.sh




if ssh -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server} 'bash -s' < /root/shells_updater_new.sh; then

echo "Шеллы успешно обновлены на ${server}"
else
echo "Ошибка обновления шеллов на ${server}"
fi


else

echo "В списке серверов не указаны порты"
exit 0

fi


done < /root/main_servers_list

#while IFS=":" read server passwordserver server_id; do
#ssh -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server} 'bash ~/shells_updater.sh'
#echo -e " ${GREEN}Now we connect to $server !${NC}"
#echo "Success update shells on ${server}"
#sleep 2
#done < /root/main_servers_list
}
#######################################################################		

get_results(){

rm -rf /root/download
mkdir -p /root/download

while IFS=":" read server port passwordserver server_id; do

#sshpass -p ${passwordserver} scp -r -P$port root@${server}:/var/www/ku/data/www/${server}/app/webroot/data/ ./download/$server_id/


if scp -i ~/.ssh/id_rsa -r -P$port root@${server}:/var/www/ku/data/www/${server}/app/webroot/data/ ./download/$server_id/; then
echo "Папка Data успешно загружена с ${server}"
else
echo "Ошибка загрузки папки Data c ${server}"
fi

if scp -i ~/.ssh/id_rsa -r -P$port root@${server}:/var/www/ku/data/www/${server}/app/webroot/data2/ ./download/$server_id/; then
echo "Папка Data2 успешно загружена с ${server}"
else
echo "Ошибка загрузки папки Data2 c ${server}"
fi

done < /root/main_servers_list

}
#######################################################################

sort_and_join_results(){


foldername="$date"
fullpath=/root/$foldername
fullpathzip=$fullpath.7z

mkdir -p $fullpath


mkdir -p $fullpath/hash
mkdir -p $fullpath/nohash
mkdir -p $fullpath/data


find /root/download/ -type f -name '*Hash_big.txt' | xargs cat > $fullpath/hash/big_$date.txt
find /root/download/ -type f -name '*Hash_corp.txt' | xargs cat > $fullpath/hash/corp_$date.txt
find /root/download/ -type f -name '*Hash_sred.txt' | xargs cat > $fullpath/hash/sred_$date.txt

find /root/download/ -type f -name '*Nohash_big.txt' | xargs cat > $fullpath/nohash/big_$date.txt
find /root/download/ -type f -name '*Nohash_corp.txt' | xargs cat > $fullpath/nohash/corp_$date.txt
find /root/download/ -type f -name '*Nohash_sred.txt' | xargs cat > $fullpath/nohash/sred_$date.txt

#собираем линки на папки в которых искать файлы
while IFS=":" read server passwordserver server_id; do


find /root/download/$server_id/data2/ -type d -name big >> $fullpath/bigfiles_path
find /root/download/$server_id/data2/ -type d -name corp >> $fullpath/corpsfiles_path
find /root/download/$server_id/data2/ -type d -name sred >> $fullpath/sredfiles_path

done < /root/main_servers_list


while read bigfiles; do

find $bigfiles -type f -name "*.*" | xargs cat >> $fullpath/data/big_$date.txt

done < $fullpath/bigfiles_path


while read corpsfiles; do

find $corpsfiles -type f -name "*.*" | xargs cat >> $fullpath/data/corps_$date.txt

done < $fullpath/corpsfiles_path


while read sredfiles; do

find $sredfiles -type f -name "*.*" | xargs cat >> $fullpath/data/sred_$date.txt

done < $fullpath/sredfiles_path


rm $fullpath/bigfiles_path
rm $fullpath/corpsfiles_path
rm $fullpath/sredfiles_path


echo "Объединение и сортировка файлов закончены. Данные лежат в папке $fullpath"


#echo $foldername
#echo $fullpath
#echo $fullpathzip
#cp -r /var/www/ku/data/www/$IP/app/webroot/data $fullpath
#cp -r /var/www/ku/data/www/$IP/app/webroot/data2 $fullpath
#find /var/www/ku/data/logs -mindepth 1 -maxdepth 1 | xargs rm -rf
}

#######################################################################

remote_delete_downloaded_files(){

while IFS=":" read server port passwordserver server_id; do

cat > ~/remote_delete_downloaded_files.sh << ELF
#!/bin/bash
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/data -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/data2 -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/slivpass_save -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/slivpass_save_solt/ -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/links -maxdepth 2 -type f -exec truncate --size 0 "{}" \;
rm /var/www/ku/data/www/IP_TO_REPLACE/app/tmp/logs/error.log
find /var/www/ku/data/logs -mindepth 1 -maxdepth 1 | xargs rm -rf
ELF

sed -i "s#\<IP_TO_REPLACE\>#$server#g" /root/remote_delete_downloaded_files.sh

ssh -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server} 'bash -s' < /root/remote_delete_downloaded_files.sh

done < /root/main_servers_list
}

#######################################################################

remote_delete_logs(){


while IFS=":" read server port passwordserver server_id; do

cat > ~/remote_delete_logs.sh << ELF
#!/bin/bash
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/slivpass_save -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/slivpass_save_solt/ -mindepth 1 -maxdepth 1 | xargs rm -rf
find /var/www/ku/data/www/IP_TO_REPLACE/app/webroot/links -maxdepth 2 -type f -exec truncate --size 0 "{}" \;
rm /var/www/ku/data/www/IP_TO_REPLACE/app/tmp/logs/error.log
find /var/www/ku/data/logs -mindepth 1 -maxdepth 1 | xargs rm -rf
ELF

sed -i "s#\<IP_TO_REPLACE\>#$server#g" /root/remote_delete_logs.sh

ssh -p $port -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no root@${server} 'bash -s' < /root/remote_delete_logs.sh

echo "мусор на $server успешно очищен"

done < /root/main_servers_list
}


#######################################################################

update_system
install_dep

#cat *adminpaneldata*.txt

################################################




f_banner
echo -e "\e[34m---------------------------------------------------------------------------------------------------------\e[00m"
echo -e "\e[93m[+]\e[00m Выберите требуемую опцию"
echo -e "\e[34m---------------------------------------------------------------------------------------------------------\e[00m"
echo ""
echo "1. Обновить шеллы на серверах"
echo "2. Скачать и отсортировать результаты"
echo "3. Чистка мусора на всех серверах"

echo "0. Exit"
echo

read choice2

case $choice2 in

1)
check_main_servers_list
generate_and_copy_ssh_key
remote_sib_copy_shells
;;

2)
check_main_servers_list
get_results
sort_and_join_results
remote_delete_downloaded_files
;;

3)
remote_delete_logs
;;

0)
exit 0
;;

esac

echo ""
  echo ""
  echo "Press [enter] to restart script or [q] and then [enter] to quit"
  read x
  if [[ "$x" == 'q' ]]
  then
    break
  fi
done
